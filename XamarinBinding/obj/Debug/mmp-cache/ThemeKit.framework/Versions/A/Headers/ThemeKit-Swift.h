// Generated by Apple Swift version 5.1.2 effective-4.2 (swiftlang-1100.0.278 clang-1100.0.33.9)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AppKit;
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ThemeKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSColor;
@class NSGradient;
@class NSImage;

/// Theme protocol: the base of all themes.
/// <em>ThemeKit</em> makes available, without any further coding:
/// <ul>
///   <li>
///     a <code>LightTheme</code> (the default macOS theme)
///   </li>
///   <li>
///     a <code>DarkTheme</code> (the dark macOS theme, using <code>NSAppearanceNameVibrantDark</code>)
///   </li>
///   <li>
///     a <code>SystemTheme</code> (which dynamically resolve to either <code>LightTheme</code> or `DarkTheme
///     depending on the macOS preference at <em>System Preferences > General > Appearance</em>)
///   </li>
/// </ul>
/// You can choose wheter or not to use these, and you can also implement your custom
/// themes by:
/// <ul>
///   <li>
///     implementing native <code>Theme</code> classes conforming to this protocol and <code>NSObject</code>
///   </li>
///   <li>
///     provide user themes (<code>UserTheme</code>) with <code>.theme</code> files
///   </li>
/// </ul>
/// Please check the provided <em>Demo.app</em> project for sample implementations of both.
SWIFT_PROTOCOL_NAMED("Theme")
@protocol TKTheme <NSObject>
/// Unique theme identifier.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Theme display name.
@property (nonatomic, readonly, copy) NSString * _Nonnull displayName;
/// Theme short display name.
@property (nonatomic, readonly, copy) NSString * _Nonnull shortDisplayName;
/// Is this a dark theme?
@property (nonatomic, readonly) BOOL isDarkTheme;
@optional
/// Optional: foreground color to be used on when a foreground color is not provided
/// by the theme.
@property (nonatomic, readonly, strong) NSColor * _Nullable fallbackForegroundColor;
/// Optional: background color to be used on when a background color (a color which
/// contains <code>Background</code> in its name) is not provided by the theme.
@property (nonatomic, readonly, strong) NSColor * _Nullable fallbackBackgroundColor;
/// Optional: gradient to be used on when a gradient is not provided by the theme.
@property (nonatomic, readonly, strong) NSGradient * _Nullable fallbackGradient;
/// Optional: image to be used on when an image is not provided by the theme.
@property (nonatomic, readonly, strong) NSImage * _Nullable fallbackImage;
@end


/// Dark theme.
SWIFT_CLASS_NAMED("DarkTheme")
@interface TKDarkTheme : NSObject <TKTheme>
/// Dark theme identifier (static).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull identifier;)
+ (NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
+ (void)setIdentifier:(NSString * _Nonnull)value;
/// Unique theme identifier.
@property (nonatomic, copy) NSString * _Nonnull identifier;
/// Theme display name.
@property (nonatomic, copy) NSString * _Nonnull displayName;
/// Theme short display name.
@property (nonatomic, copy) NSString * _Nonnull shortDisplayName;
/// Is this a dark theme?
@property (nonatomic) BOOL isDarkTheme;
/// Calling <code>init()</code> is not allowed outside this library.
/// Use <code>ThemeManager.darkTheme</code> instead.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


/// Light theme (default).
SWIFT_CLASS_NAMED("LightTheme")
@interface TKLightTheme : NSObject <TKTheme>
/// Light theme identifier (static).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull identifier;)
+ (NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
+ (void)setIdentifier:(NSString * _Nonnull)value;
/// Unique theme identifier.
@property (nonatomic, copy) NSString * _Nonnull identifier;
/// Theme display name.
@property (nonatomic, copy) NSString * _Nonnull displayName;
/// Theme short display name.
@property (nonatomic, copy) NSString * _Nonnull shortDisplayName;
/// Is this a dark theme?
@property (nonatomic) BOOL isDarkTheme;
/// Calling <code>init()</code> is not allowed outside this library.
/// Use <code>ThemeManager.lightTheme</code> instead.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


@interface NSColor (SWIFT_EXTENSION(ThemeKit))
/// Check if color is being overriden in a ThemeColor extension.
@property (nonatomic, readonly) BOOL isThemeOverriden;
/// Get all <code>NSColor</code> color methods.
/// Overridable class methods (can be overriden in <code>ThemeColor</code> extension).
+ (NSArray<NSString *> * _Nonnull)colorMethodNames SWIFT_WARN_UNUSED_RESULT;
- (void)themeKitSet;
- (void)themeKitSetFill;
- (void)themeKitSetStroke;
@end









@class NSAppearance;

@interface NSWindow (SWIFT_EXTENSION(ThemeKit))
/// Any window specific theme.
/// This is, usually, <code>nil</code>, which means the current global theme will be used.
/// Please note that when using window specific themes, only the associated
/// <code>NSAppearance</code> will be automatically set. All theme aware assets (<code>ThemeColor</code>,
/// <code>ThemeGradient</code> and <code>ThemeImage</code>) should call methods that returns a
/// resolved color instead (which means they don’t change with the theme change,
/// you need to observe theme changes manually, and set colors afterwards):
/// <ul>
///   <li>
///     <code>ThemeColor.color(for view:, selector:)</code>
///   </li>
///   <li>
///     <code>ThemeGradient.gradient(for view:, selector:)</code>
///   </li>
///   <li>
///     <code>ThemeImage.image(for view:, selector:)</code>
///   </li>
/// </ul>
/// Additionaly, please note that system overriden colors (<code>NSColor.*</code>) will
/// always use the global theme.
@property (nonatomic, strong) id <TKTheme> _Nullable windowTheme;
/// Returns the current effective theme (read-only).
@property (nonatomic, readonly, strong) id <TKTheme> _Nonnull windowEffectiveTheme;
/// Returns the current effective appearance (read-only).
@property (nonatomic, readonly, strong) NSAppearance * _Nullable windowEffectiveThemeAppearance;
/// Theme window if needed.
- (void)theme;
/// Theme window if compliant to ThemeManager.windowThemePolicy (and if needed).
- (void)themeIfCompliantWithWindowThemePolicy;
/// Theme all windows compliant to ThemeManager.windowThemePolicy (and if needed).
+ (void)themeAllWindows;
@end


/// System theme.
/// Will dynamically resolve to either <code>ThemeManager.lightTheme</code> or <code>ThemeManager.darkTheme</code>,
/// depending on the macOS preference at <em>System Preferences > General > Appearance</em>.
SWIFT_CLASS_NAMED("SystemTheme")
@interface TKSystemTheme : NSObject <TKTheme>
/// System  theme identifier (static).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull identifier;)
+ (NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
+ (void)setIdentifier:(NSString * _Nonnull)value;
/// Unique theme identifier.
@property (nonatomic, copy) NSString * _Nonnull identifier;
/// Theme display name.
@property (nonatomic, readonly, copy) NSString * _Nonnull displayName;
/// Theme short display name.
@property (nonatomic, readonly, copy) NSString * _Nonnull shortDisplayName;
/// Is this a dark theme?
@property (nonatomic) BOOL isDarkTheme;
/// Checks if Apple UI theme is set to dark, as set on <em>System Preferences > General > Appearance</em>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL isAppleInterfaceThemeDark;)
+ (BOOL)isAppleInterfaceThemeDark SWIFT_WARN_UNUSED_RESULT;
+ (void)setIsAppleInterfaceThemeDark:(BOOL)value;
/// Calling <code>init()</code> is not allowed outside this library.
/// Use <code>ThemeManager.systemTheme</code> instead.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end


@class NSColorSpace;
@class NSCoder;

/// <code>ThemeColor</code> is a <code>NSColor</code> subclass that dynamically changes its colors whenever
/// a new theme is make current.
/// Theme-aware means you don’t need to check any conditions when choosing which
/// color to draw or set on a control. E.g.:
/// \code
/// myTextField.textColor = ThemeColor.myContentTextColor
///
/// ThemeColor.myCircleFillColor.setFill()
/// NSBezierPath(rect: bounds).fill()
///
/// \endcodeThe text color of <code>myTextField</code> will automatically change when the user switches
/// a theme. Similarly, the drawing code will draw with different color depending on
/// the selected theme. Unless some drawing cache is being done, there’s no need to
/// refresh the UI after changing the current theme.
/// You can also define a color to be a pattern image using <code>NSColor(patternImage:)</code>.
/// <h2>Defining theme-aware colors</h2>
/// The recommended way of adding your own dynamic colors is as follows:
/// <ol>
///   <li>
///     <em>Add a <code>ThemeColor</code> class extension</em> (or <code>TKThemeColor</code> category on Objective-C)
///     to add class methods for your colors. E.g.:
///     In Swift:
///     \code
///     extension ThemeColor {
///
///       static var brandColor: ThemeColor { 
///         return ThemeColor.color(with: #function)
///       }
///
///     }
///
///     \endcodeIn Objective-C:
///     \code
///     @interface TKThemeColor (Demo)
///
///     + (TKThemeColor*)brandColor;
///
///     @end
///
///     @implementation TKThemeColor (Demo)
///
///     + (TKThemeColor*)brandColor {
///       return [TKThemeColor colorWithSelector:_cmd];
///     }
///
///     @end
///
///     \endcode</li>
///   <li>
///     <em>Add Class Extensions on any <code>Theme</code> you want to support</em> (e.g., <code>LightTheme</code>
///     and <code>DarkTheme</code> - <code>TKLightTheme</code> and <code>TKDarkTheme</code> on Objective-C) to provide
///     instance methods for each theme color class method defined on (1). E.g.:
///     In Swift:
///     \code
///     extension LightTheme {
///
///       var brandColor: NSColor {
///         return NSColor.orange
///       }
///
///     }
///
///     extension DarkTheme {
///
///       var brandColor: NSColor {
///         return NSColor.white
///       }
///
///     }
///
///     \endcodeIn Objective-C:
///     \code
///     @interface TKLightTheme (Demo) @end
///
///     @implementation TKLightTheme (Demo)
///
///        - (NSColor*)brandColor
///        {
///            return [NSColor orangeColor];
///        }
///
///     @end
///
///     @interface TKDarkTheme (Demo) @end
///
///     @implementation TKDarkTheme (Demo)
///
///        - (NSColor*)brandColor
///        {
///            return [NSColor whiteColor];
///        }
///
///     @end
///
///     \endcode</li>
///   <li>
///     If supporting <code>UserTheme</code>’s, <em>define properties on user theme files</em> (<code>.theme</code>)
///     for each theme color class method defined on (1). E.g.:
///     \code
///     displayName = Sample User Theme
///     identifier = com.luckymarmot.ThemeKit.SampleUserTheme
///     darkTheme = false
///
///     brandColor = rgba(96, 240, 12, 0.5)
///
///     \endcode</li>
/// </ol>
/// <h2>Overriding system colors</h2>
/// Besides your own colors added as <code>ThemeColor</code> class methods, you can also override
/// <code>NSColor</code> class methods so that they return theme-aware colors. The procedure is
/// exactly the same, so, for example, if adding a method named <code>labelColor</code> to a
/// <code>ThemeColor</code> extension, that method will be overriden in <code>NSColor</code> and the colors
/// from <code>Theme</code> subclasses will be used instead.
/// In sum, calling <code>NSColor.labelColor</code> will return theme-aware colors.
/// You can get the full list of available/overridable color methods (class methods)
/// calling <code>NSColor.colorMethodNames()</code>.
/// At any time, you can check if a system color is being overriden by current theme
/// by checking the <code>NSColor.isThemeOverriden</code> property (e.g., <code>NSColor.labelColor.isThemeOverriden</code>).
/// When a theme does not override a system color, the original system color will be
/// used instead. E.g., you have overrided <code>ThemeColor.labelColor</code>, but currently
/// applied theme does not implement <code>labelColor</code> -> original <code>labelColor</code> will be
/// used.
/// <h2>Fallback colors</h2>
/// With the exception of system overrided named colors, which defaults to the original
/// system provided named color when theme does not specifies it, unimplemented
/// properties/methods on target theme class will default to <code>fallbackForegroundColor</code>
/// and <code>fallbackBackgroundColor</code>, for foreground and background colors respectively.
/// These too, can be customized per theme.
/// Please check <code>ThemeGradient</code> for theme-aware gradients and <code>ThemeImage</code> for theme-aware images.
SWIFT_CLASS_NAMED("ThemeColor")
@interface TKThemeColor : NSColor
/// <code>ThemeColor</code> color selector used as theme instance method for same selector
/// or, if inexistent, as argument in the theme instance method <code>themeAsset(_:)</code>.
@property (nonatomic) SEL _Nonnull themeColorSelector;
/// Resolved color from current theme (dynamically changes with the current theme).
@property (nonatomic, strong) NSColor * _Nonnull resolvedThemeColor;
/// Create a new ThemeColor instance for the specified selector.
/// Returns a color returned by calling <code>selector</code> on current theme as an instance method or,
/// if unavailable, the result of calling <code>themeAsset(_:)</code> on the current theme.
/// \param selector Selector for color method.
///
///
/// returns:
/// A <code>ThemeColor</code> instance for the specified selector.
+ (TKThemeColor * _Nonnull)colorWithSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Color for a specific theme.
/// \param theme A <code>Theme</code> instance.
///
/// \param selector A color selector.
///
///
/// returns:
/// Resolved color for specified selector on given theme.
+ (NSColor * _Nonnull)colorForTheme:(id <TKTheme> _Nonnull)theme selector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Current theme color, but respecting view appearance and any window
/// specific theme (if set).
/// If a <code>NSWindow.windowTheme</code> was set, it will be used instead.
/// Some views may be using a different appearance than the theme appearance.
/// In thoses cases, color won’t be resolved using current theme, but from
/// either <code>lightTheme</code> or <code>darkTheme</code>, depending of whether view appearance
/// is light or dark, respectively.
/// \param view A <code>NSView</code> instance.
///
/// \param selector A color selector.
///
///
/// returns:
/// Resolved color for specified selector on given view.
+ (NSColor * _Nonnull)colorForView:(NSView * _Nonnull)view selector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Forces dynamic color resolution into <code>resolvedThemeColor</code> and cache it.
/// You should not need to manually call this function.
- (void)recacheColor;
/// Clear all caches.
/// You should not need to manually call this function.
+ (void)emptyCache;
- (void)setFill;
- (void)setStroke;
- (void)set;
- (NSColor * _Nullable)colorUsingColorSpace:(NSColorSpace * _Nonnull)space SWIFT_WARN_UNUSED_RESULT;
- (NSColor * _Nullable)colorUsingColorSpaceName:(NSColorSpaceName _Nullable)colorSpace device:(NSDictionary<NSDeviceDescriptionKey, id> * _Nullable)deviceDescription SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSColorSpaceName _Nonnull colorSpaceName;
@property (nonatomic, readonly, strong) NSColorSpace * _Nonnull colorSpace;
@property (nonatomic, readonly) NSInteger numberOfComponents;
- (void)getComponents:(CGFloat * _Nonnull)components;
@property (nonatomic, readonly) CGFloat redComponent;
@property (nonatomic, readonly) CGFloat greenComponent;
@property (nonatomic, readonly) CGFloat blueComponent;
- (void)getRed:(CGFloat * _Nullable)red green:(CGFloat * _Nullable)green blue:(CGFloat * _Nullable)blue alpha:(CGFloat * _Nullable)alpha;
@property (nonatomic, readonly) CGFloat cyanComponent;
@property (nonatomic, readonly) CGFloat magentaComponent;
@property (nonatomic, readonly) CGFloat yellowComponent;
@property (nonatomic, readonly) CGFloat blackComponent;
- (void)getCyan:(CGFloat * _Nullable)cyan magenta:(CGFloat * _Nullable)magenta yellow:(CGFloat * _Nullable)yellow black:(CGFloat * _Nullable)black alpha:(CGFloat * _Nullable)alpha;
@property (nonatomic, readonly) CGFloat whiteComponent;
- (void)getWhite:(CGFloat * _Nullable)white alpha:(CGFloat * _Nullable)alpha;
@property (nonatomic, readonly) CGFloat hueComponent;
@property (nonatomic, readonly) CGFloat saturationComponent;
@property (nonatomic, readonly) CGFloat brightnessComponent;
- (void)getHue:(CGFloat * _Nullable)hue saturation:(CGFloat * _Nullable)saturation brightness:(CGFloat * _Nullable)brightness alpha:(CGFloat * _Nullable)alpha;
- (NSColor * _Nullable)highlightWithLevel:(CGFloat)val SWIFT_WARN_UNUSED_RESULT;
- (NSColor * _Nullable)shadowWithLevel:(CGFloat)val SWIFT_WARN_UNUSED_RESULT;
- (NSColor * _Nonnull)colorWithAlphaComponent:(CGFloat)alpha SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithPasteboardPropertyList:(id _Nonnull)propertyList ofType:(NSPasteboardType _Nonnull)type OBJC_DESIGNATED_INITIALIZER;
@end

@class NSBezierPath;

/// <code>ThemeGradient</code> is a <code>NSGradient</code> subclass that dynamically changes its colors
/// whenever a new theme is make current.
/// Theme-aware means you don’t need to check any conditions when choosing which
/// gradient to draw. E.g.:
/// \code
/// ThemeGradient.rainbowGradient.draw(in: bounds, angle: 0)
///
/// \endcodeThe drawing code will draw with different gradient depending on the selected
/// theme. Unless some drawing cache is being done, there’s no need to refresh the
/// UI after changing the current theme.
/// <h2>Defining theme-aware gradients</h2>
/// The recommended way of adding your own dynamic gradients is as follows:
/// <ol>
///   <li>
///     <em>Add a <code>ThemeGradient</code> class extension</em> (or <code>TKThemeGradient</code> category on
///     Objective-C) to add class methods for your gradients. E.g.:
///     In Swift:
///     \code
///     extension ThemeGradient {
///
///         static var brandGradient: ThemeGradient {
///            return ThemeGradient.gradient(with: #function)
///         }
///
///     }
///
///     \endcodeIn Objective-C:
///     \code
///     @interface TKThemeGradient (Demo)
///
///     + (TKThemeGradient*)brandGradient;
///
///     @end
///
///     @implementation TKThemeGradient (Demo)
///
///     + (TKThemeGradient*)brandGradient {
///        return [TKThemeGradient gradientWithSelector:_cmd];
///     }
///
///     @end
///
///     \endcode</li>
///   <li>
///     <em>Add Class Extensions on any <code>Theme</code> you want to support</em> (e.g., <code>LightTheme</code>
///     and <code>DarkTheme</code> - <code>TKLightTheme</code> and <code>TKDarkTheme</code> on Objective-C) to provide
///     instance methods for each theme gradient class method defined on (1). E.g.:
///     In Swift:
///     \code
///     extension LightTheme {
///
///         var brandGradient: NSGradient {
///            return NSGradient(starting: NSColor.white, ending: NSColor.black)
///         }
///         
///         }
///         
///         extension DarkTheme {
///         
///         var brandGradient: NSGradient {
///            return NSGradient(starting: NSColor.black, ending: NSColor.white)
///         }
///
///     }
///
///     \endcodeIn Objective-C:
///     \code
///     @interface TKLightTheme (Demo) @end
///
///     @implementation TKLightTheme (Demo)
///
///     - (NSGradient*)brandGradient
///     {
///        return [[NSGradient alloc] initWithStartingColor:[NSColor whiteColor] endingColor:[NSColor blackColor]];
///     }
///
///     @end
///
///     @interface TKDarkTheme (Demo) @end
///
///     @implementation TKDarkTheme (Demo)
///
///     - (NSGradient*)brandGradient
///     {
///        return [[NSGradient alloc] initWithStartingColor:[NSColor blackColor] endingColor:[NSColor whiteColor]];
///     }
///
///     @end
///
///     \endcode</li>
///   <li>
///     If supporting <code>UserTheme</code>’s, <em>define properties on user theme files</em> (<code>.theme</code>)
///     for each theme gradient class method defined on (1). E.g.:
///     \code
///     displayName = Sample User Theme
///     identifier = com.luckymarmot.ThemeKit.SampleUserTheme
///     darkTheme = false
///
///     orangeSky = rgb(160, 90, 45, .5)
///     brandGradient = linear-gradient($orangeSky, rgb(200, 140, 60))
///
///     \endcode</li>
/// </ol>
/// <h2>Fallback colors</h2>
/// Unimplemented properties/methods on target theme class will default to
/// <code>fallbackGradient</code>. This too, can be customized per theme.
/// Please check <code>ThemeColor</code> for theme-aware colors and <code>ThemeImage</code> for theme-aware images.
SWIFT_CLASS_NAMED("ThemeGradient")
@interface TKThemeGradient : NSGradient
/// <code>ThemeGradient</code> gradient selector used as theme instance method for same
/// selector or, if inexistent, as argument in the theme instance method <code>themeAsset(_:)</code>.
@property (nonatomic) SEL _Nullable themeGradientSelector;
/// Resolved gradient from current theme (dynamically changes with the current theme).
@property (nonatomic, strong) NSGradient * _Nullable resolvedThemeGradient;
/// Create a new ThemeGradient instance for the specified selector.
/// \param selector Selector for color method.
///
///
/// returns:
/// A <code>ThemeGradient</code> instance for the specified selector.
+ (TKThemeGradient * _Nullable)gradientWithSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Gradient for a specific theme.
/// \param theme A <code>Theme</code> instance.
///
/// \param selector A gradient selector.
///
///
/// returns:
/// Resolved gradient for specified selector on given theme.
+ (NSGradient * _Nullable)gradientForTheme:(id <TKTheme> _Nonnull)theme selector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Current theme gradient, but respecting view appearance and any window
/// specific theme (if set).
/// If a <code>NSWindow.windowTheme</code> was set, it will be used instead.
/// Some views may be using a different appearance than the theme appearance.
/// In thoses cases, gradient won’t be resolved using current theme, but from
/// either <code>lightTheme</code> or <code>darkTheme</code>, depending of whether view appearance
/// is light or dark, respectively.
/// \param view A <code>NSView</code> instance.
///
/// \param selector A gradient selector.
///
///
/// returns:
/// Resolved gradient for specified selector on given view.
+ (NSGradient * _Nullable)gradientForView:(NSView * _Nonnull)view selector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
/// Forces dynamic gradient resolution into <code>resolvedThemeGradient</code> and cache it.
/// You should not need to manually call this function.
- (void)recacheGradient;
/// Clear all caches.
/// You should not need to manually call this function.
+ (void)emptyCache;
- (void)drawInRect:(NSRect)rect angle:(CGFloat)angle;
- (void)drawInBezierPath:(NSBezierPath * _Nonnull)path angle:(CGFloat)angle;
- (void)drawFromPoint:(NSPoint)startingPoint toPoint:(NSPoint)endingPoint options:(NSGradientDrawingOptions)options;
- (void)drawFromCenter:(NSPoint)startCenter radius:(CGFloat)startRadius toCenter:(NSPoint)endCenter radius:(CGFloat)endRadius options:(NSGradientDrawingOptions)options;
- (void)drawInRect:(NSRect)rect relativeCenterPosition:(NSPoint)relativeCenterPosition;
- (void)drawInBezierPath:(NSBezierPath * _Nonnull)path relativeCenterPosition:(NSPoint)relativeCenterPosition;
@property (nonatomic, readonly, strong) NSColorSpace * _Nonnull colorSpace;
@property (nonatomic, readonly) NSInteger numberOfColorStops;
- (void)getColor:(NSColor * _Nonnull * _Nullable)color location:(CGFloat * _Nullable)location atIndex:(NSInteger)index;
- (NSColor * _Nonnull)interpolatedColorAtLocation:(CGFloat)location SWIFT_WARN_UNUSED_RESULT;
- (nullable instancetype)initWithColors:(NSArray<NSColor *> * _Nonnull)colorArray atLocations:(CGFloat const * _Nullable)locations colorSpace:(NSColorSpace * _Nonnull)colorSpace SWIFT_UNAVAILABLE;
@end

@class NSImageRep;
@protocol NSImageDelegate;
@class NSGraphicsContext;

/// <code>ThemeImage</code> is a <code>NSImage</code> subclass that dynamically changes its colors
/// whenever a new theme is make current.
/// Theme-aware means you don’t need to check any conditions when choosing which
/// image to draw. E.g.:
/// \code
/// ThemeImage.logoImage.draw(in: bounds)
///
/// \endcodeThe drawing code will draw with different image depending on the selected
/// theme. Unless some drawing cache is being done, there’s no need to refresh the
/// UI after changing the current theme.
/// <h2>Defining theme-aware images</h2>
/// The recommended way of adding your own dynamic images is as follows:
/// <ol>
///   <li>
///     <em>Add a <code>ThemeImage</code> class extension</em> (or <code>TKThemeImage</code> category on
///     Objective-C) to add class methods for your images. E.g.:
///     In Swift:
///     \code
///     extension ThemeImage {
///
///         static var logoImage: ThemeImage {
///             return ThemeImage.image(with: #function)
///         }
///
///     }
///
///     \endcodeIn Objective-C:
///     \code
///     @interface TKThemeImage (Demo)
///
///     + (TKThemeImage*)logoImage;
///
///     @end
///
///     @implementation TKThemeImage (Demo)
///
///     + (TKThemeImage*)logoImage {
///         return [TKThemeImage imageWithSelector:_cmd];
///     }
///
///     @end
///
///     \endcode</li>
///   <li>
///     <em>Add Class Extensions on any <code>Theme</code> you want to support</em> (e.g., <code>LightTheme</code>
///     and <code>DarkTheme</code> - <code>TKLightTheme</code> and <code>TKDarkTheme</code> on Objective-C) to provide
///     instance methods for each theme image class method defined on (1). E.g.:
///     In Swift:
///     \code
///     extension LightTheme {
///
///         var logoImage: NSImage? {
///             return NSImage(named: "MyLightLogo")
///         }
///
///     }
///
///     extension DarkTheme {
///
///         var logoImage: NSImage? {
///             return NSImage(contentsOfFile: "somewhere/MyDarkLogo.png")
///         }
///
///     }
///
///     \endcodeIn Objective-C:
///     \code
///     @interface TKLightTheme (Demo) @end
///
///     @implementation TKLightTheme (Demo)
///
///     - (NSImage*)logoImage
///     {
///         return [NSImage imageNamed:@"MyLightLogo"];
///     }
///
///     @end
///
///     @interface TKDarkTheme (Demo) @end
///
///     @implementation TKDarkTheme (Demo)
///
///     - (NSImage*)logoImage
///     {
///         return [NSImage alloc] initWithContentsOfFile:@"somewhere/MyDarkLogo.png"];
///     }
///
///     @end
///
///     \endcode</li>
///   <li>
///     If supporting <code>UserTheme</code>’s, <em>define properties on user theme files</em> (<code>.theme</code>)
///     for each theme image class method defined on (1). E.g.:
///     \code
///     displayName = Sample User Theme
///     identifier = com.luckymarmot.ThemeKit.SampleUserTheme
///     darkTheme = false
///
///     logoImage = image(named:MyLogo)
///     //logoImage = image(file:../some/path/MyLogo.png)
///
///     \endcode</li>
/// </ol>
/// <h2>Fallback images</h2>
/// Unimplemented properties/methods on target theme class will default to
/// <code>fallbackImage</code>. This too, can be customized per theme.
/// Please check <code>ThemeColor</code> for theme-aware colors and <code>ThemeGradient</code> for theme-aware gradients.
SWIFT_CLASS_NAMED("ThemeImage")
@interface TKThemeImage : NSImage
/// <code>ThemeImage</code> image selector used as theme instance method for same
/// selector or, if inexistent, as argument in the theme instance method <code>themeAsset(_:)</code>.
@property (nonatomic) SEL _Nullable themeImageSelector;
/// Resolved Image from current theme (dynamically changes with the current theme).
@property (nonatomic, strong) NSImage * _Nonnull resolvedThemeImage;
/// Create a new ThemeImage instance for the specified selector.
/// Returns an image returned by calling <code>selector</code> on current theme as an instance method or,
/// if unavailable, the result of calling <code>themeAsset(_:)</code> on the current theme.
/// \param selector Selector for image method.
///
///
/// returns:
/// A <code>ThemeImage</code> instance for the specified selector.
+ (TKThemeImage * _Nonnull)imageWithSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Image for a specific theme.
/// \param theme A <code>Theme</code> instance.
///
/// \param selector An image selector.
///
///
/// returns:
/// Resolved image for specified selector on given theme.
+ (NSImage * _Nullable)imageForTheme:(id <TKTheme> _Nonnull)theme selector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Current theme image, but respecting view appearance and any window
/// specific theme (if set).
/// If a <code>NSWindow.windowTheme</code> was set, it will be used instead.
/// Some views may be using a different appearance than the theme appearance.
/// In thoses cases, image won’t be resolved using current theme, but from
/// either <code>lightTheme</code> or <code>darkTheme</code>, depending of whether view appearance
/// is light or dark, respectively.
/// \param view A <code>NSView</code> instance.
///
/// \param selector An image selector.
///
///
/// returns:
/// Resolved image for specified selector on given view.
+ (NSImage * _Nullable)imageForView:(NSView * _Nonnull)view selector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
/// Forces dynamic color resolution into <code>resolvedThemeImage</code> and cache it.
/// You should not need to manually call this function.
- (void)recacheImage;
/// Clear all caches.
/// You should not need to manually call this function.
+ (void)emptyCache;
@property (nonatomic) NSSize size;
- (BOOL)setName:(NSImageName _Nullable)string SWIFT_WARN_UNUSED_RESULT;
- (NSImageName _Nullable)name SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) NSColor * _Nonnull backgroundColor;
@property (nonatomic) BOOL usesEPSOnResolutionMismatch;
@property (nonatomic) BOOL prefersColorMatch;
@property (nonatomic) BOOL matchesOnMultipleResolution;
@property (nonatomic) BOOL matchesOnlyOnBestFittingAxis;
- (void)drawAtPoint:(NSPoint)point fromRect:(NSRect)fromRect operation:(NSCompositingOperation)op fraction:(CGFloat)delta;
- (void)drawInRect:(NSRect)rect fromRect:(NSRect)fromRect operation:(NSCompositingOperation)op fraction:(CGFloat)delta;
- (void)drawInRect:(NSRect)dstSpacePortionRect fromRect:(NSRect)srcSpacePortionRect operation:(NSCompositingOperation)op fraction:(CGFloat)requestedAlpha respectFlipped:(BOOL)respectContextIsFlipped hints:(NSDictionary<NSImageHintKey, id> * _Nullable)hints;
- (BOOL)drawRepresentation:(NSImageRep * _Nonnull)imageRep inRect:(NSRect)rect SWIFT_WARN_UNUSED_RESULT;
- (void)drawInRect:(NSRect)rect;
- (void)recache;
@property (nonatomic, readonly, copy) NSData * _Nullable TIFFRepresentation;
- (NSData * _Nullable)TIFFRepresentationUsingCompression:(NSTIFFCompression)comp factor:(float)factor SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSArray<NSImageRep *> * _Nonnull representations;
- (void)addRepresentations:(NSArray<NSImageRep *> * _Nonnull)imageReps;
- (void)addRepresentation:(NSImageRep * _Nonnull)imageRep;
- (void)removeRepresentation:(NSImageRep * _Nonnull)imageRep;
@property (nonatomic, readonly, getter=isValid) BOOL valid;
- (void)lockFocus;
- (void)lockFocusFlipped:(BOOL)flipped;
- (void)unlockFocus;
@property (nonatomic, strong) id <NSImageDelegate> _Nullable delegate;
- (void)cancelIncrementalLoad;
@property (nonatomic) NSImageCacheMode cacheMode;
@property (nonatomic) NSRect alignmentRect;
@property (nonatomic, getter=isTemplate, setter=setTemplate:) BOOL template_;
@property (nonatomic, copy) NSString * _Nullable accessibilityDescription;
- (CGImageRef _Nullable)CGImageForProposedRect:(NSRect * _Nullable)proposedDestRect context:(NSGraphicsContext * _Nullable)referenceContext hints:(NSDictionary<NSImageHintKey, id> * _Nullable)hints SWIFT_WARN_UNUSED_RESULT;
- (NSImageRep * _Nullable)bestRepresentationForRect:(NSRect)rect context:(NSGraphicsContext * _Nullable)referenceContext hints:(NSDictionary<NSImageHintKey, id> * _Nullable)hints SWIFT_WARN_UNUSED_RESULT;
- (BOOL)hitTestRect:(NSRect)testRectDestSpace withImageDestinationRect:(NSRect)imageRectDestSpace context:(NSGraphicsContext * _Nullable)context hints:(NSDictionary<NSImageHintKey, id> * _Nullable)hints flipped:(BOOL)flipped SWIFT_WARN_UNUSED_RESULT;
- (CGFloat)recommendedLayerContentsScale:(CGFloat)preferredContentsScale SWIFT_WARN_UNUSED_RESULT;
- (id _Nonnull)layerContentsForContentsScale:(CGFloat)layerContentsScale SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic) NSEdgeInsets capInsets;
@property (nonatomic) NSImageResizingMode resizingMode;
- (nonnull instancetype)initWithSize:(NSSize)size OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithPasteboardPropertyList:(id _Nonnull)propertyList ofType:(NSPasteboardType _Nonnull)type OBJC_DESIGNATED_INITIALIZER;
@end


/// Use <code>ThemeManager</code> shared instance to perform app-wide theming related operations,
/// such as:
/// <ul>
///   <li>
///     Get information about current theme/appearance
///   </li>
///   <li>
///     Change current <code>theme</code> (can also be changed from <code>NSUserDefaults</code>)
///   </li>
///   <li>
///     List available themes
///   </li>
///   <li>
///     Define <code>ThemeKit</code> behaviour
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("ThemeManager")
@interface TKThemeManager : NSObject
/// ThemeManager shared manager.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) TKThemeManager * _Nonnull sharedManager;)
+ (TKThemeManager * _Nonnull)sharedManager SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// Enables or disables ThemeKit functionality.
@property (nonatomic) BOOL isEnabled;
/// Sets or returns the current theme.
/// This property is KVO compliant. Value is stored on user defaults under key
/// <code>userDefaultsThemeKey</code>.
@property (nonatomic, strong) id <TKTheme> _Nonnull theme;
/// Returns the current effective theme (read-only).
/// This property is KVO compliant. This can return a different result than
/// <code>theme</code>, as if current theme is set to <code>SystemTheme</code>, effective theme
/// will be either <code>lightTheme</code> or <code>darkTheme</code>, respecting user preference at
/// <em>System Preferences > General > Appearance</em>.
@property (nonatomic, readonly, strong) id <TKTheme> _Nonnull effectiveTheme;
/// List all available themes:
/// <ul>
///   <li>
///     Built-in <code>lightTheme</code>
///   </li>
///   <li>
///     Built-in <code>darkTheme</code>
///   </li>
///   <li>
///     Built-in <code>systemTheme</code>
///   </li>
///   <li>
///     All native themes (extending <code>NSObject</code> and conforming to <code>Theme</code> protocol)
///   </li>
///   <li>
///     All user themes (loaded from <code>.theme</code> files)
///   </li>
/// </ul>
/// This property is KVO compliant and will change when changes occur on user
/// themes folder.
@property (nonatomic, readonly, copy) NSArray<id <TKTheme>> * _Nonnull themes;
/// List all user themes (<code>UserTheme</code> class, loaded from <code>.theme</code> files)
@property (nonatomic, readonly, copy) NSArray<id <TKTheme>> * _Nonnull userThemes;
/// Convenience method for accessing the light theme.
/// This property can be changed so that <code>SystemTheme</code> resolves to this theme
/// instead of the default <code>LightTheme</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <TKTheme> _Nonnull lightTheme;)
+ (id <TKTheme> _Nonnull)lightTheme SWIFT_WARN_UNUSED_RESULT;
+ (void)setLightTheme:(id <TKTheme> _Nonnull)value;
/// Convenience method for accessing the dark theme.
/// This property can be changed so that <code>SystemTheme</code> resolves to this theme
/// instead of the default <code>DarkTheme</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <TKTheme> _Nonnull darkTheme;)
+ (id <TKTheme> _Nonnull)darkTheme SWIFT_WARN_UNUSED_RESULT;
+ (void)setDarkTheme:(id <TKTheme> _Nonnull)value;
/// Convenience method for accessing the theme that dynamically changes to
/// <code>ThemeManager.lightTheme</code> or <code>ThemeManager.darkTheme</code>, respecting user preference
/// at <em>System Preferences > General > Appearance</em>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) TKSystemTheme * _Nonnull systemTheme;)
+ (TKSystemTheme * _Nonnull)systemTheme SWIFT_WARN_UNUSED_RESULT;
/// Set/get default theme to be used on the first run (default: <code>ThemeManager.systemTheme</code>).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <TKTheme> _Nonnull defaultTheme;)
+ (id <TKTheme> _Nonnull)defaultTheme SWIFT_WARN_UNUSED_RESULT;
+ (void)setDefaultTheme:(id <TKTheme> _Nonnull)value;
/// Get the theme with specified identifier.
/// \param identifier The unique <code>Theme.identifier</code> string.
///
///
/// returns:
/// The <code>Theme</code> instance with the given identifier.
- (id <TKTheme> _Nullable)themeWithIdentifier:(NSString * _Nullable)identifier SWIFT_WARN_UNUSED_RESULT;
/// User defaults key for current <code>theme</code>.
/// Current <code>theme.identifier</code> will be stored under the <code>"ThemeKitTheme"</code> <code>NSUserDefaults</code> key.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull userDefaultsThemeKey;)
+ (NSString * _Nonnull)userDefaultsThemeKey SWIFT_WARN_UNUSED_RESULT;
/// Apply last applied theme, or default, if none.
/// Get last applied theme from user defaults and load it. If no theme was
/// previously applied, load the default theme (<code>ThemeManager.defaultTheme</code>).
- (void)applyLastOrDefaultTheme;
/// Force-apply current <code>theme</code>.
/// Normally you should not need to invoke this method, as this will
/// force-apply the same theme.
- (void)reApplyCurrentTheme;
/// Location of user provided themes (.theme files).
/// Ideally, this should be on a shared location, like <code>Application Support/{app_bundle_id}/Themes</code>
/// for example. Here’s an example of how to get this folder (*):
/// \code
/// public var applicationSupportUserThemesFolderURL: URL {
///   let applicationSupportURLs = NSSearchPathForDirectoriesInDomains(.applicationSupportDirectory, .userDomainMask, true)
///   let thisAppSupportURL = URL(fileURLWithPath: applicationSupportURLs.first!).appendingPathComponent(Bundle.main.bundleIdentifier!)
///   return thisAppSupportURL.appendingPathComponent("Themes")
/// }
///
/// \endcode*: force wrapping (!) is for illustrative purposes only.
/// You can also bundle these files with your application bundle, if you
/// don’t want them to be changed.
@property (nonatomic, copy) NSURL * _Nullable userThemesFolderURL;
/// Appearance in use for effective theme.
@property (nonatomic, readonly, strong) NSAppearance * _Nonnull effectiveThemeAppearance;
/// Convenience method to get the light appearance.
@property (nonatomic, readonly, strong) NSAppearance * _Nullable lightAppearance;
/// Convenience method to get the dark appearance.
@property (nonatomic, readonly, strong) NSAppearance * _Nullable darkAppearance;
/// Animate theme transitions?
@property (nonatomic) BOOL animateThemeTransitions;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
/// ThemeKit notification sent when current theme is about to change.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull willChangeThemeNotification;)
+ (NSNotificationName _Nonnull)willChangeThemeNotification SWIFT_WARN_UNUSED_RESULT;
/// ThemeKit notification sent when current theme did change.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull didChangeThemeNotification;)
+ (NSNotificationName _Nonnull)didChangeThemeNotification SWIFT_WARN_UNUSED_RESULT;
/// ThemeKit notification sent when system theme did change (System Preference > General > Appearance).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSNotificationName _Nonnull didChangeSystemThemeNotification;)
+ (NSNotificationName _Nonnull)didChangeSystemThemeNotification SWIFT_WARN_UNUSED_RESULT;
@end

enum TKThemeManagerWindowThemePolicy : NSInteger;

@interface TKThemeManager (SWIFT_EXTENSION(ThemeKit))
/// Current window theme policy.
@property (nonatomic) enum TKThemeManagerWindowThemePolicy windowThemePolicy;
/// Windows classes to be excluded from theming with the <code>TKThemeManagerWindowThemePolicyDoNotThemeSomeWindows</code>.
@property (nonatomic, copy) NSArray<Class> * _Nullable notThemableWindowClasses;
/// Windows classes to be themed with the <code>TKThemeManagerWindowThemePolicyThemeSomeWindows</code>.
@property (nonatomic, copy) NSArray<Class> * _Nullable themableWindowClasses;
@end

/// Window theme policies that define which windows should be automatically themed, if any (Objective-C variant, only).
typedef SWIFT_ENUM_NAMED(NSInteger, TKThemeManagerWindowThemePolicy, "TKThemeManagerWindowThemePolicy", closed) {
/// Theme all application windows (default).
  TKThemeManagerWindowThemePolicyThemeAllWindows = 0,
/// Only theme windows of the specified classes.
  TKThemeManagerWindowThemePolicyThemeSomeWindows = 1,
/// Do not theme windows of the specified classes.
  TKThemeManagerWindowThemePolicyDoNotThemeSomeWindows = 2,
/// Do not theme any window.
  TKThemeManagerWindowThemePolicyDoNotThemeWindows = 3,
};




/// A <code>Theme</code> class wrapping a user provided theme file (<code>.theme</code>).
/// To enable user themes, set theme folder on <code>ThemeManager.userThemesFolderURL</code>.
/// Notes about <code>.theme</code> files:
/// <ul>
///   <li>
///     lines starting with <code>#</code> or <code>//</code> will be treated as comments, thus, ignored;
///   </li>
///   <li>
///     non-comment lines consists on simple variable/value assignments (eg, <code>variable = value</code>);
///   </li>
///   <li>
///     <code>variable</code> name can contain characters <code>[a-zA-Z0-9_-.]+</code>;
///   </li>
///   <li>
///     custom variables can be specified (eg, <code>myBackgroundColor = ...</code>);
///   </li>
///   <li>
///     theming properties match the class methods of <code>ThemeColor</code>, <code>ThemeGradient</code> and <code>ThemeImage</code> (eg, <code>labelColor</code>);
///   </li>
///   <li>
///     variables can be referenced by prefixing them with <code>$</code> (eg, <code>mainBorderColor = $commonBorderColor</code>);
///   </li>
///   <li>
///     colors are defined using <code>rgb(255, 255, 255)</code> or <code>rgba(255, 255, 255, 1.0)</code> (case insensitive);
///   </li>
///   <li>
///     gradients are defined using <code>linear-gradient(color1, color2)</code> (where colors are defined as above; case insensitive);
///   </li>
///   <li>
///     pattern images are defined using <code>pattern(named:xxxx)</code> (named images) or <code>pattern(file:../dddd/xxxx.yyy)</code> (filesystem images);
///   </li>
///   <li>
///     images are defined using <code>image(named:xxxx)</code> (named images) or <code>image(file:../dddd/xxxx.yyy)</code> (filesystem images);
///   </li>
///   <li>
///     <code>ThemeManager.themes</code> property is automatically updated when there are changes on the user themes folder;
///   </li>
///   <li>
///     file changes are applied on-the-fly, if it corresponds to the currently applied theme.
///   </li>
/// </ul>
/// Example <code>.theme</code> file:
/// \code
/// // ************************* Theme Info ************************* //
/// displayName = My Theme 1
/// identifier = com.luckymarmot.ThemeKit.MyTheme1
/// darkTheme = true
///
/// // ********************* Colors & Gradients ********************* //
/// # define color for `ThemeColor.brandColor`
/// brandColor = $blue
/// # define a new color for `NSColor.labelColor` (overriding)
/// labelColor = rgb(11, 220, 111)
/// # define gradient for `ThemeGradient.brandGradient`
/// brandGradient = linear-gradient($orange.sky, rgba(200, 140, 60, 1.0))
///
/// // ********************* Images & Patterns ********************** //
/// # define pattern image from named image "paper" for color `ThemeColor.contentBackgroundColor`
/// contentBackgroundColor = pattern(named:paper)
/// # define pattern image from filesystem (relative to user themes folder) for color `ThemeColor.bottomBackgroundColor`
/// bottomBackgroundColor = pattern(file:../some/path/some-file.png)
/// # use named image "apple"
/// namedImage = image(named:apple)
/// # use image from filesystem (relative to user themes folder)
/// fileImage = image(file:../some/path/some-file.jpg)
///
/// // *********************** Common Colors ************************ //
/// blue = rgb(0, 170, 255)
/// orange.sky = rgb(160, 90, 45, .5)
///
/// // ********************** Fallback Assets *********************** //
/// fallbackForegroundColor = rgb(255, 10, 90, 1.0)
/// fallbackBackgroundColor = rgb(255, 200, 190)
/// fallbackGradient = linear-gradient($blue, rgba(200, 140, 60, 1.0))
///
/// \endcodeWith the exception of system overrided named colors (e.g., <code>labelColor</code>), which
/// defaults to the original system provided named color, unimplemented properties
/// on theme file will default to <code>-fallbackForegroundColor</code>, <code>-fallbackBackgroundColor</code>,
/// <code>-fallbackGradient</code> and <code>-fallbackImage</code>, for foreground color, background color,
/// gradients and images, respectively.
SWIFT_CLASS_NAMED("UserTheme")
@interface TKUserTheme : NSObject <TKTheme>
/// Unique theme identifier.
@property (nonatomic, copy) NSString * _Nonnull identifier;
/// Theme display name.
@property (nonatomic, copy) NSString * _Nonnull displayName;
/// Theme short display name.
@property (nonatomic, copy) NSString * _Nonnull shortDisplayName;
/// Is this a dark theme?
@property (nonatomic) BOOL isDarkTheme;
/// File URL.
@property (nonatomic, copy) NSURL * _Nullable fileURL;
/// <code>init()</code> is disabled.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// Reloads user theme from file.
- (void)reload;
/// Theme asset for the specified key. Supported assets are <code>NSColor</code>, <code>NSGradient</code>, <code>NSImage</code> and <code>NSString</code>.
/// \param key A color name, gradient name, image name or a theme string
///
///
/// returns:
/// The theme value for the specified key.
- (id _Nullable)themeAsset:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Checks if a theme asset is provided for the given key.
/// Do not check for theme asset availability with <code>themeAsset(_:)</code>, use
/// this method instead, which is much faster.
/// \param key A color name, gradient name, image name or a theme string
///
///
/// returns:
/// <code>true</code> if theme provides an asset for the given key; <code>false</code> otherwise.
- (BOOL)hasThemeAsset:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
